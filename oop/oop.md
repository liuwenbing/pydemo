# OOp-Python面向对象

- Python的面向对象
- 面向对象编程
    - 基础
    - 公有私有
    - 继承
    - 组合 minx
- 魔法函数
    - 魔法函数的概述
    - 构造函数魔法函数
    - 运算类魔法函数
        
# 1 面向对象描述（ObjectOriented，oo）
- oop思想
    - 接触到任意一个任务，首先想到的是任务世界的构成，由模型构成
- 几个名词
    -  oo:面向对象
    -  ooa:***分析
    -  。。。。。
    - 

# 2. 类和对象的概念
- 实例话类
    变量 = 类名（）
    
    obj.成员属性
    obj.方法
- 可以通过内置变量检查类的成员变量和方法
     - 对象的所有成员 obj__dict__ 
     - 类的所有成员  class_name.__dict__


# 3. annoca 使用
 - conda list
 - conda env list:显示虚拟环境
 - conda create -n xxx python=3.6  ：创建版本为3.6的虚拟环境 名称为xxx
 
 
# 4 类的对象的成员分析
- 类和对象可以存储成员，成员可以归类所有，也可以归对象所有
- 类存储成员时使用的是与类关联的一个对象
- 独享存储成员是存储在当前对象中 
- 对象访问一个成员时，一定使用对象中的成员，尝试访问类的成员，如果有对象只能够有此成员。一定使用对象中的成员
- 创建对象的时候，，类中的成员不会放入对象中，而是得到一个空的对象，没有成员
- 通过对象 对类中成员重新赋值或者通过对象添加成员时，对应成员会保存在对象中，而不会修改类成员

# 5 关于self
- self在对象的方法中表示当前对象本身，如果通过对象调用一个方法，那么该对象会自动传入到当前方法的第一个参数中
- self 本身不是关键字，只是一个接受对象的普通参数，理论上可以用任意一个变量代替
- 当法中有self形参的方法称为非绑定的方法,可以接受对象访问，没有self的是绑定类的方法，只能通过类访问
- 使用类访问绑定类的方法时，如果类方法中需要访问当前类的成员，可以通过__class__  成员来访问
# 6 面向对象特性
- 继承
- 封装
- 多态

## 6.1 封装
- 封装就是对成员进行访问限制
- 私有
            class Person():
	        name = "liu" #公有
	            #—__age私有、
	         __age = 12
	- Python私有不是真的私有，是一种name mangling的改名策略         
    - 可以使用对象。 _classname_attributename访问
    
    
- 受保护的对象 
    - 受保护的封装的是对象成员进行一定级别的封装，然后，在类中或者自类中都可以进行访问，但是在外部不可以，
    - 封装方法 在成员名称前添加一个下划线即可
-  公开的 public 
    - 公共的封装实际成员没有任何操作，任何地方都可以访问
    
## 6.2 继承
- 继承就是一个类可以获得另外一个类的成员属性和方法

- 俗称->自类是父类的一个子集

- 作用 减少代码  增加代码的复用度 同时可以设置类与类之间的关系
- 继承与被继承的概念：
    - 被继承的类叫父类 ，也叫基类，超类
    - 用于继承的类 也叫子类 派生类
    - 继承与被继承一定存在一个is-a 关系
- 继承的特征
    - 所有的类都继承自object，即所有的类都是object类的子类
    - 子类一代呢继承父类，则可以使用父类中除私有成员方法属性外
    - 子类中可以定义独有的成员属性和方法
    - 子类中定义的成员和方法，可以在定义新的方法的同时访问父类成员来进行代码重用，
      可以使用【父类名.父类成员】的格式来调用父类成员，也可以使用super()，父类成员的格式来调用 
- 继承变量函数的查找顺序
    - 优先查找自己的变量
    - 没有则查父类函数
    - 构造函数如果本类中没有定义，则自动查找调用父类的构造函数
- 构造函数 
    - 是一类特殊的函数，在实例话之前被调用
    - 如果定义类构造函数，则实例化使用构造函数，不查找父类的函数
    - 如果没有定义，则自动查找父类的构造函数
    - 如果子类没定义，父类的构造函数带参数，则构造函数应该按父类参数构造
- super
    - super不是关键字，而是一个类
    - super的作用是获取MRO(MethodResolustionOrder)列表中的第一个类
    - super 于父类直接没有任何的实质性关系，但通过super可以调用到父类
    - super 使用两个方法，参见构造函数中调用父类的构造函数      