# OOp-Python面向对象

- Python的面向对象
- 面向对象编程
    - 基础
    - 公有私有
    - 继承
    - 组合 minx
- 魔法函数
    - 魔法函数的概述
    - 构造函数魔法函数
    - 运算类魔法函数
        
# 1 面向对象描述（ObjectOriented，oo）
- oop思想
    - 接触到任意一个任务，首先想到的是任务世界的构成，由模型构成
- 几个名词
    -  oo:面向对象
    -  ooa:***分析
    -  。。。。。
    - 

# 2. 类和对象的概念
- 实例话类
    变量 = 类名（）
    
    obj.成员属性
    obj.方法
- 可以通过内置变量检查类的成员变量和方法
     - 对象的所有成员 obj__dict__ 
     - 类的所有成员  class_name.__dict__


# 3. annoca 使用
 - conda list
 - conda env list:显示虚拟环境
 - conda create -n xxx python=3.6  ：创建版本为3.6的虚拟环境 名称为xxx
 
 
# 4 类的对象的成员分析
- 类和对象可以存储成员，成员可以归类所有，也可以归对象所有
- 类存储成员时使用的是与类关联的一个对象
- 独享存储成员是存储在当前对象中 
- 对象访问一个成员时，一定使用对象中的成员，尝试访问类的成员，如果有对象只能够有此成员。一定使用对象中的成员
- 创建对象的时候，，类中的成员不会放入对象中，而是得到一个空的对象，没有成员
- 通过对象 对类中成员重新赋值或者通过对象添加成员时，对应成员会保存在对象中，而不会修改类成员

# 5 关于self
- self在对象的方法中表示当前对象本身，如果通过对象调用一个方法，那么该对象会自动传入到当前方法的第一个参数中
- self 本身不是关键字，只是一个接受对象的普通参数，理论上可以用任意一个变量代替
- 当法中有self形参的方法称为非绑定的方法,可以接受对象访问，没有self的是绑定类的方法，只能通过类访问
- 使用类访问绑定类的方法时，如果类方法中需要访问当前类的成员，可以通过__class__  成员来访问
# 6 面向对象特性
- 继承
- 封装
- 多态

## 6.1 封装
- 封装就是对成员进行访问限制
- 私有
            class Person():
	        name = "liu" #公有
	            #—__age私有、
	         __age = 12
	- Python私有不是真的私有，是一种name mangling的改名策略         
    - 可以使用对象。 _classname_attributename访问
    
    
- 受保护的对象 
    - 受保护的封装的是对象成员进行一定级别的封装，然后，在类中或者自类中都可以进行访问，但是在外部不可以，
    - 封装方法 在成员名称前添加一个下划线即可
-  公开的 public 
    - 公共的封装实际成员没有任何操作，任何地方都可以访问
    
## 6.2 继承
- 继承就是一个类可以获得另外一个类的成员属性和方法

- 俗称->自类是父类的一个子集

- 作用 减少代码  增加代码的复用度 同时可以设置类与类之间的关系
- 继承与被继承的概念：
    - 被继承的类叫父类 ，也叫基类，超类
    - 用于继承的类 也叫子类 派生类
    - 继承与被继承一定存在一个is-a 关系
- 继承的特征
    - 所有的类都继承自object，即所有的类都是object类的子类
    - 子类一代呢继承父类，则可以使用父类中除私有成员方法属性外
    - 子类中可以定义独有的成员属性和方法
    - 子类中定义的成员和方法，可以在定义新的方法的同时访问父类成员来进行代码重用，
      可以使用【父类名.父类成员】的格式来调用父类成员，也可以使用super()，父类成员的格式来调用 
- 继承变量函数的查找顺序
    - 优先查找自己的变量
    - 没有则查父类函数
    - 构造函数如果本类中没有定义，则自动查找调用父类的构造函数
- 构造函数 
    - 是一类特殊的函数，在实例话之前被调用
    - 如果定义类构造函数，则实例化使用构造函数，不查找父类的函数
    - 如果没有定义，则自动查找父类的构造函数
    - 如果子类没定义，父类的构造函数带参数，则构造函数应该按父类参数构造
- super
    - super不是关键字，而是一个类
    - super的作用是获取MRO(MethodResolustionOrder)列表中的第一个类
    - super 于父类直接没有任何的实质性关系，但通过super可以调用到父类
    - super 使用两个方法，参见构造函数中调用父类的构造函数      
- 单继承与多继承
    - 每个类只能继承一个类
    - 每个类只能继承多个类
    
- 单继承多继承优缺点
    - 但继承：
        - 传承有序逻辑清晰语法简单隐患少
        - 功能不能无限扩展,只能在当前唯一的继承中扩展
        - 比较混乱
        
        
- 构造函数
    - 是自动被调用的,在实例化，系统自动调用构造函数，通常这就叫做实例化对象
    - 构造函数一定要有， 如果没有，则自动向上查找，按照MRO顺序，直到找到位置
    
##  多态
- 多态就是同一个对象在不同情况下有不同的形态
- 多态不是一种语法，而是一种设计思想
- 多态性： 一种调用方式，不同的执行效果
- 多态 ：同一事物的多种形态
    -Mixin设计模式
    
- 我们使用多继承来实现mixin  
- 使用mixin要多加小心
    - 首先他必须表示某单一功能，而不是一个物品
    - 职责必须单一，如果由多个功能，则写多个
    - mixin 不能依赖子类
    - 子类即使没有继承mixin类，也可以照样工作，只是缺少类某个功能
    
- 优点
    - 使用mixin可以在不对类进行修改的情况下修改，扩充功能
    - 可以方便的组织和维护不同功能的组件
    - 可以根据需要任意调整功能类的组合
    - 可以避免创建很多新的类， 导致类的继承混乱
    
#4 类的函数

- issubclass  :检测一个类是否含有另外一个类
- isinstance : 检测一个对象是否是一个类的实例
- hasattr:检测一个对象是否由成员xxxxx
- getattr ......    

# 5.类的属性定义
- 类的成员描述符是为了在类中对类的成员属性进行相关操作而创建的一种方式
    - get
    - set
    - delete
- 如果想使用类的成员描述符，大概有三种方法
    - 使用类的实现描述器
    - 使用属性修饰符
    - 使用property
        -property函数很简单
        -property（fget,fset,fdel,foc）
    - 案例参考oop.py
    
- 无论那种修饰符都是为了对成员属性进行相应的控制
    - 类的方式：适合多个类中的多个属性公用一个描述符
    - property 使用当前类中的使用，可以控制一个类中的多个属性
    - 属性修饰符 使用当前类中使用，控制一个类中的一个属性
    
    
#6 类的内置属性 
-  __dict__
   __doc__
   __name__
   __bases__  
   
#7 类的魔术方法
- 魔术方法就是不需要人为调用的方法，基本是在特定时刻自动触发
- 统一调用： 方法名被前后两个下划线包裹
- '__init__'   初始化
- '__new__'   对象实例话方法，此函数特殊，一般不调用
- '__call__'  对象当函数时触发
- '__srt__' 当对象被当作字符串的时候调用
- '__repr__' 返回字符串，

-描述符相关
    - '__set__'
    - '__get__'
    - '__delete__'
- 属性相关操作
    - '__getattr__' :访问一个不存在的属性时触发
    - '__setattr__' :对成员属性进行操作的时候触发
        - 参数
         - self用来获取当前对象
         - 被设置的属性名称，以字符串的形式出现
         - 需要对属性名称设置的值
        - 作用：进行属性设置的时候进行验证或者修改
        - 注意：在该方法中不能对属性进行直接的赋值，否则进入死循环
        - 参考案例
- 运算分类相关的魔术方法
    - '__gt__' :进行大于判断的操作
        - 参数
            -'self'
            - 第二个参数是第二个对象
            - 返回值可以是任意值，推荐返回布尔值
            - 案例
            
    
#8 类和对象的三种方法
- 案例方法
    - 需要实例话对象才能使用的方法。，使用过程中可能需要截止对象的其他方法来完成
- 静态方法
    - 不需要实例化,通过类直接访问
- 类方法
    - 不要要实例化
- 参考案例
- 三个方法区别清百度        
                     
    
                       
              